// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: userservice.proto

#ifndef PROTOBUF_userservice_2eproto__INCLUDED
#define PROTOBUF_userservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_userservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsUserRequestImpl();
void InitDefaultsUserRequest();
void InitDefaultsUserResponseImpl();
void InitDefaultsUserResponse();
void InitDefaultsAppDemoImpl();
void InitDefaultsAppDemo();
void InitDefaultsMixInfoImpl();
void InitDefaultsMixInfo();
inline void InitDefaults() {
  InitDefaultsUserRequest();
  InitDefaultsUserResponse();
  InitDefaultsAppDemo();
  InitDefaultsMixInfo();
}
}  // namespace protobuf_userservice_2eproto
namespace userservice {
class AppDemo;
class AppDemoDefaultTypeInternal;
extern AppDemoDefaultTypeInternal _AppDemo_default_instance_;
class MixInfo;
class MixInfoDefaultTypeInternal;
extern MixInfoDefaultTypeInternal _MixInfo_default_instance_;
class UserRequest;
class UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResponse;
class UserResponseDefaultTypeInternal;
extern UserResponseDefaultTypeInternal _UserResponse_default_instance_;
}  // namespace userservice
namespace userservice {

// ===================================================================

class UserRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userservice.UserRequest) */ {
 public:
  UserRequest();
  virtual ~UserRequest();

  UserRequest(const UserRequest& from);

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRequest(UserRequest&& from) noexcept
    : UserRequest() {
    *this = ::std::move(from);
  }

  inline UserRequest& operator=(UserRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(UserRequest* other);
  friend void swap(UserRequest& a, UserRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UserRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 1;
  void clear_userid();
  static const int kUseridFieldNumber = 1;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // @@protoc_insertion_point(class_scope:userservice.UserRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  mutable int _cached_size_;
  friend struct ::protobuf_userservice_2eproto::TableStruct;
  friend void ::protobuf_userservice_2eproto::InitDefaultsUserRequestImpl();
};
// -------------------------------------------------------------------

class UserResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userservice.UserResponse) */ {
 public:
  UserResponse();
  virtual ~UserResponse();

  UserResponse(const UserResponse& from);

  inline UserResponse& operator=(const UserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserResponse(UserResponse&& from) noexcept
    : UserResponse() {
    *this = ::std::move(from);
  }

  inline UserResponse& operator=(UserResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserResponse* internal_default_instance() {
    return reinterpret_cast<const UserResponse*>(
               &_UserResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(UserResponse* other);
  friend void swap(UserResponse& a, UserResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  UserResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserResponse& from);
  void MergeFrom(const UserResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 2;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // .userservice.MixInfo result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::userservice::MixInfo& result() const;
  ::userservice::MixInfo* release_result();
  ::userservice::MixInfo* mutable_result();
  void set_allocated_result(::userservice::MixInfo* result);

  // int32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:userservice.UserResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::userservice::MixInfo* result_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_userservice_2eproto::TableStruct;
  friend void ::protobuf_userservice_2eproto::InitDefaultsUserResponseImpl();
};
// -------------------------------------------------------------------

class AppDemo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userservice.AppDemo) */ {
 public:
  AppDemo();
  virtual ~AppDemo();

  AppDemo(const AppDemo& from);

  inline AppDemo& operator=(const AppDemo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppDemo(AppDemo&& from) noexcept
    : AppDemo() {
    *this = ::std::move(from);
  }

  inline AppDemo& operator=(AppDemo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppDemo& default_instance();

  enum RequestCase {
    kUserrequest = 1,
    kUserresponse = 2,
    kMixinfo = 3,
    REQUEST_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppDemo* internal_default_instance() {
    return reinterpret_cast<const AppDemo*>(
               &_AppDemo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AppDemo* other);
  friend void swap(AppDemo& a, AppDemo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppDemo* New() const PROTOBUF_FINAL { return New(NULL); }

  AppDemo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AppDemo& from);
  void MergeFrom(const AppDemo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AppDemo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .userservice.UserRequest userrequest = 1;
  bool has_userrequest() const;
  void clear_userrequest();
  static const int kUserrequestFieldNumber = 1;
  const ::userservice::UserRequest& userrequest() const;
  ::userservice::UserRequest* release_userrequest();
  ::userservice::UserRequest* mutable_userrequest();
  void set_allocated_userrequest(::userservice::UserRequest* userrequest);

  // .userservice.UserResponse userresponse = 2;
  bool has_userresponse() const;
  void clear_userresponse();
  static const int kUserresponseFieldNumber = 2;
  const ::userservice::UserResponse& userresponse() const;
  ::userservice::UserResponse* release_userresponse();
  ::userservice::UserResponse* mutable_userresponse();
  void set_allocated_userresponse(::userservice::UserResponse* userresponse);

  // .userservice.MixInfo mixinfo = 3;
  bool has_mixinfo() const;
  void clear_mixinfo();
  static const int kMixinfoFieldNumber = 3;
  const ::userservice::MixInfo& mixinfo() const;
  ::userservice::MixInfo* release_mixinfo();
  ::userservice::MixInfo* mutable_mixinfo();
  void set_allocated_mixinfo(::userservice::MixInfo* mixinfo);

  RequestCase Request_case() const;
  // @@protoc_insertion_point(class_scope:userservice.AppDemo)
 private:
  void set_has_userrequest();
  void set_has_userresponse();
  void set_has_mixinfo();

  inline bool has_Request() const;
  void clear_Request();
  inline void clear_has_Request();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestUnion {
    RequestUnion() {}
    ::userservice::UserRequest* userrequest_;
    ::userservice::UserResponse* userresponse_;
    ::userservice::MixInfo* mixinfo_;
  } Request_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_userservice_2eproto::TableStruct;
  friend void ::protobuf_userservice_2eproto::InitDefaultsAppDemoImpl();
};
// -------------------------------------------------------------------

class MixInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:userservice.MixInfo) */ {
 public:
  MixInfo();
  virtual ~MixInfo();

  MixInfo(const MixInfo& from);

  inline MixInfo& operator=(const MixInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MixInfo(MixInfo&& from) noexcept
    : MixInfo() {
    *this = ::std::move(from);
  }

  inline MixInfo& operator=(MixInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MixInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MixInfo* internal_default_instance() {
    return reinterpret_cast<const MixInfo*>(
               &_MixInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MixInfo* other);
  friend void swap(MixInfo& a, MixInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MixInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MixInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MixInfo& from);
  void MergeFrom(const MixInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MixInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string orgname = 2;
  void clear_orgname();
  static const int kOrgnameFieldNumber = 2;
  const ::std::string& orgname() const;
  void set_orgname(const ::std::string& value);
  #if LANG_CXX11
  void set_orgname(::std::string&& value);
  #endif
  void set_orgname(const char* value);
  void set_orgname(const char* value, size_t size);
  ::std::string* mutable_orgname();
  ::std::string* release_orgname();
  void set_allocated_orgname(::std::string* orgname);

  // string orgid = 3;
  void clear_orgid();
  static const int kOrgidFieldNumber = 3;
  const ::std::string& orgid() const;
  void set_orgid(const ::std::string& value);
  #if LANG_CXX11
  void set_orgid(::std::string&& value);
  #endif
  void set_orgid(const char* value);
  void set_orgid(const char* value, size_t size);
  ::std::string* mutable_orgid();
  ::std::string* release_orgid();
  void set_allocated_orgid(::std::string* orgid);

  // string enterprise = 4;
  void clear_enterprise();
  static const int kEnterpriseFieldNumber = 4;
  const ::std::string& enterprise() const;
  void set_enterprise(const ::std::string& value);
  #if LANG_CXX11
  void set_enterprise(::std::string&& value);
  #endif
  void set_enterprise(const char* value);
  void set_enterprise(const char* value, size_t size);
  ::std::string* mutable_enterprise();
  ::std::string* release_enterprise();
  void set_allocated_enterprise(::std::string* enterprise);

  // string enterpriseid = 5;
  void clear_enterpriseid();
  static const int kEnterpriseidFieldNumber = 5;
  const ::std::string& enterpriseid() const;
  void set_enterpriseid(const ::std::string& value);
  #if LANG_CXX11
  void set_enterpriseid(::std::string&& value);
  #endif
  void set_enterpriseid(const char* value);
  void set_enterpriseid(const char* value, size_t size);
  ::std::string* mutable_enterpriseid();
  ::std::string* release_enterpriseid();
  void set_allocated_enterpriseid(::std::string* enterpriseid);

  // @@protoc_insertion_point(class_scope:userservice.MixInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr orgname_;
  ::google::protobuf::internal::ArenaStringPtr orgid_;
  ::google::protobuf::internal::ArenaStringPtr enterprise_;
  ::google::protobuf::internal::ArenaStringPtr enterpriseid_;
  mutable int _cached_size_;
  friend struct ::protobuf_userservice_2eproto::TableStruct;
  friend void ::protobuf_userservice_2eproto::InitDefaultsMixInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserRequest

// string userid = 1;
inline void UserRequest::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRequest::userid() const {
  // @@protoc_insertion_point(field_get:userservice.UserRequest.userid)
  return userid_.GetNoArena();
}
inline void UserRequest::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.UserRequest.userid)
}
#if LANG_CXX11
inline void UserRequest::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.UserRequest.userid)
}
#endif
inline void UserRequest::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.UserRequest.userid)
}
inline void UserRequest::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.UserRequest.userid)
}
inline ::std::string* UserRequest::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:userservice.UserRequest.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRequest::release_userid() {
  // @@protoc_insertion_point(field_release:userservice.UserRequest.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRequest::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:userservice.UserRequest.userid)
}

// -------------------------------------------------------------------

// UserResponse

// int32 code = 1;
inline void UserResponse::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 UserResponse::code() const {
  // @@protoc_insertion_point(field_get:userservice.UserResponse.code)
  return code_;
}
inline void UserResponse::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:userservice.UserResponse.code)
}

// string message = 2;
inline void UserResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserResponse::message() const {
  // @@protoc_insertion_point(field_get:userservice.UserResponse.message)
  return message_.GetNoArena();
}
inline void UserResponse::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.UserResponse.message)
}
#if LANG_CXX11
inline void UserResponse::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.UserResponse.message)
}
#endif
inline void UserResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.UserResponse.message)
}
inline void UserResponse::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.UserResponse.message)
}
inline ::std::string* UserResponse::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:userservice.UserResponse.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserResponse::release_message() {
  // @@protoc_insertion_point(field_release:userservice.UserResponse.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserResponse::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:userservice.UserResponse.message)
}

// .userservice.MixInfo result = 3;
inline bool UserResponse::has_result() const {
  return this != internal_default_instance() && result_ != NULL;
}
inline void UserResponse::clear_result() {
  if (GetArenaNoVirtual() == NULL && result_ != NULL) {
    delete result_;
  }
  result_ = NULL;
}
inline const ::userservice::MixInfo& UserResponse::result() const {
  const ::userservice::MixInfo* p = result_;
  // @@protoc_insertion_point(field_get:userservice.UserResponse.result)
  return p != NULL ? *p : *reinterpret_cast<const ::userservice::MixInfo*>(
      &::userservice::_MixInfo_default_instance_);
}
inline ::userservice::MixInfo* UserResponse::release_result() {
  // @@protoc_insertion_point(field_release:userservice.UserResponse.result)
  
  ::userservice::MixInfo* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::userservice::MixInfo* UserResponse::mutable_result() {
  
  if (result_ == NULL) {
    result_ = new ::userservice::MixInfo;
  }
  // @@protoc_insertion_point(field_mutable:userservice.UserResponse.result)
  return result_;
}
inline void UserResponse::set_allocated_result(::userservice::MixInfo* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete result_;
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:userservice.UserResponse.result)
}

// -------------------------------------------------------------------

// AppDemo

// .userservice.UserRequest userrequest = 1;
inline bool AppDemo::has_userrequest() const {
  return Request_case() == kUserrequest;
}
inline void AppDemo::set_has_userrequest() {
  _oneof_case_[0] = kUserrequest;
}
inline void AppDemo::clear_userrequest() {
  if (has_userrequest()) {
    delete Request_.userrequest_;
    clear_has_Request();
  }
}
inline ::userservice::UserRequest* AppDemo::release_userrequest() {
  // @@protoc_insertion_point(field_release:userservice.AppDemo.userrequest)
  if (has_userrequest()) {
    clear_has_Request();
      ::userservice::UserRequest* temp = Request_.userrequest_;
    Request_.userrequest_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::userservice::UserRequest& AppDemo::userrequest() const {
  // @@protoc_insertion_point(field_get:userservice.AppDemo.userrequest)
  return has_userrequest()
      ? *Request_.userrequest_
      : *reinterpret_cast< ::userservice::UserRequest*>(&::userservice::_UserRequest_default_instance_);
}
inline ::userservice::UserRequest* AppDemo::mutable_userrequest() {
  if (!has_userrequest()) {
    clear_Request();
    set_has_userrequest();
    Request_.userrequest_ = new ::userservice::UserRequest;
  }
  // @@protoc_insertion_point(field_mutable:userservice.AppDemo.userrequest)
  return Request_.userrequest_;
}

// .userservice.UserResponse userresponse = 2;
inline bool AppDemo::has_userresponse() const {
  return Request_case() == kUserresponse;
}
inline void AppDemo::set_has_userresponse() {
  _oneof_case_[0] = kUserresponse;
}
inline void AppDemo::clear_userresponse() {
  if (has_userresponse()) {
    delete Request_.userresponse_;
    clear_has_Request();
  }
}
inline ::userservice::UserResponse* AppDemo::release_userresponse() {
  // @@protoc_insertion_point(field_release:userservice.AppDemo.userresponse)
  if (has_userresponse()) {
    clear_has_Request();
      ::userservice::UserResponse* temp = Request_.userresponse_;
    Request_.userresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::userservice::UserResponse& AppDemo::userresponse() const {
  // @@protoc_insertion_point(field_get:userservice.AppDemo.userresponse)
  return has_userresponse()
      ? *Request_.userresponse_
      : *reinterpret_cast< ::userservice::UserResponse*>(&::userservice::_UserResponse_default_instance_);
}
inline ::userservice::UserResponse* AppDemo::mutable_userresponse() {
  if (!has_userresponse()) {
    clear_Request();
    set_has_userresponse();
    Request_.userresponse_ = new ::userservice::UserResponse;
  }
  // @@protoc_insertion_point(field_mutable:userservice.AppDemo.userresponse)
  return Request_.userresponse_;
}

// .userservice.MixInfo mixinfo = 3;
inline bool AppDemo::has_mixinfo() const {
  return Request_case() == kMixinfo;
}
inline void AppDemo::set_has_mixinfo() {
  _oneof_case_[0] = kMixinfo;
}
inline void AppDemo::clear_mixinfo() {
  if (has_mixinfo()) {
    delete Request_.mixinfo_;
    clear_has_Request();
  }
}
inline ::userservice::MixInfo* AppDemo::release_mixinfo() {
  // @@protoc_insertion_point(field_release:userservice.AppDemo.mixinfo)
  if (has_mixinfo()) {
    clear_has_Request();
      ::userservice::MixInfo* temp = Request_.mixinfo_;
    Request_.mixinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::userservice::MixInfo& AppDemo::mixinfo() const {
  // @@protoc_insertion_point(field_get:userservice.AppDemo.mixinfo)
  return has_mixinfo()
      ? *Request_.mixinfo_
      : *reinterpret_cast< ::userservice::MixInfo*>(&::userservice::_MixInfo_default_instance_);
}
inline ::userservice::MixInfo* AppDemo::mutable_mixinfo() {
  if (!has_mixinfo()) {
    clear_Request();
    set_has_mixinfo();
    Request_.mixinfo_ = new ::userservice::MixInfo;
  }
  // @@protoc_insertion_point(field_mutable:userservice.AppDemo.mixinfo)
  return Request_.mixinfo_;
}

inline bool AppDemo::has_Request() const {
  return Request_case() != REQUEST_NOT_SET;
}
inline void AppDemo::clear_has_Request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline AppDemo::RequestCase AppDemo::Request_case() const {
  return AppDemo::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MixInfo

// string username = 1;
inline void MixInfo::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MixInfo::username() const {
  // @@protoc_insertion_point(field_get:userservice.MixInfo.username)
  return username_.GetNoArena();
}
inline void MixInfo::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.MixInfo.username)
}
#if LANG_CXX11
inline void MixInfo::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.MixInfo.username)
}
#endif
inline void MixInfo::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.MixInfo.username)
}
inline void MixInfo::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.MixInfo.username)
}
inline ::std::string* MixInfo::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:userservice.MixInfo.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixInfo::release_username() {
  // @@protoc_insertion_point(field_release:userservice.MixInfo.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixInfo::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:userservice.MixInfo.username)
}

// string orgname = 2;
inline void MixInfo::clear_orgname() {
  orgname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MixInfo::orgname() const {
  // @@protoc_insertion_point(field_get:userservice.MixInfo.orgname)
  return orgname_.GetNoArena();
}
inline void MixInfo::set_orgname(const ::std::string& value) {
  
  orgname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.MixInfo.orgname)
}
#if LANG_CXX11
inline void MixInfo::set_orgname(::std::string&& value) {
  
  orgname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.MixInfo.orgname)
}
#endif
inline void MixInfo::set_orgname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  orgname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.MixInfo.orgname)
}
inline void MixInfo::set_orgname(const char* value, size_t size) {
  
  orgname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.MixInfo.orgname)
}
inline ::std::string* MixInfo::mutable_orgname() {
  
  // @@protoc_insertion_point(field_mutable:userservice.MixInfo.orgname)
  return orgname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixInfo::release_orgname() {
  // @@protoc_insertion_point(field_release:userservice.MixInfo.orgname)
  
  return orgname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixInfo::set_allocated_orgname(::std::string* orgname) {
  if (orgname != NULL) {
    
  } else {
    
  }
  orgname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orgname);
  // @@protoc_insertion_point(field_set_allocated:userservice.MixInfo.orgname)
}

// string orgid = 3;
inline void MixInfo::clear_orgid() {
  orgid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MixInfo::orgid() const {
  // @@protoc_insertion_point(field_get:userservice.MixInfo.orgid)
  return orgid_.GetNoArena();
}
inline void MixInfo::set_orgid(const ::std::string& value) {
  
  orgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.MixInfo.orgid)
}
#if LANG_CXX11
inline void MixInfo::set_orgid(::std::string&& value) {
  
  orgid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.MixInfo.orgid)
}
#endif
inline void MixInfo::set_orgid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  orgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.MixInfo.orgid)
}
inline void MixInfo::set_orgid(const char* value, size_t size) {
  
  orgid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.MixInfo.orgid)
}
inline ::std::string* MixInfo::mutable_orgid() {
  
  // @@protoc_insertion_point(field_mutable:userservice.MixInfo.orgid)
  return orgid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixInfo::release_orgid() {
  // @@protoc_insertion_point(field_release:userservice.MixInfo.orgid)
  
  return orgid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixInfo::set_allocated_orgid(::std::string* orgid) {
  if (orgid != NULL) {
    
  } else {
    
  }
  orgid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orgid);
  // @@protoc_insertion_point(field_set_allocated:userservice.MixInfo.orgid)
}

// string enterprise = 4;
inline void MixInfo::clear_enterprise() {
  enterprise_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MixInfo::enterprise() const {
  // @@protoc_insertion_point(field_get:userservice.MixInfo.enterprise)
  return enterprise_.GetNoArena();
}
inline void MixInfo::set_enterprise(const ::std::string& value) {
  
  enterprise_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.MixInfo.enterprise)
}
#if LANG_CXX11
inline void MixInfo::set_enterprise(::std::string&& value) {
  
  enterprise_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.MixInfo.enterprise)
}
#endif
inline void MixInfo::set_enterprise(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  enterprise_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.MixInfo.enterprise)
}
inline void MixInfo::set_enterprise(const char* value, size_t size) {
  
  enterprise_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.MixInfo.enterprise)
}
inline ::std::string* MixInfo::mutable_enterprise() {
  
  // @@protoc_insertion_point(field_mutable:userservice.MixInfo.enterprise)
  return enterprise_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixInfo::release_enterprise() {
  // @@protoc_insertion_point(field_release:userservice.MixInfo.enterprise)
  
  return enterprise_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixInfo::set_allocated_enterprise(::std::string* enterprise) {
  if (enterprise != NULL) {
    
  } else {
    
  }
  enterprise_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enterprise);
  // @@protoc_insertion_point(field_set_allocated:userservice.MixInfo.enterprise)
}

// string enterpriseid = 5;
inline void MixInfo::clear_enterpriseid() {
  enterpriseid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MixInfo::enterpriseid() const {
  // @@protoc_insertion_point(field_get:userservice.MixInfo.enterpriseid)
  return enterpriseid_.GetNoArena();
}
inline void MixInfo::set_enterpriseid(const ::std::string& value) {
  
  enterpriseid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userservice.MixInfo.enterpriseid)
}
#if LANG_CXX11
inline void MixInfo::set_enterpriseid(::std::string&& value) {
  
  enterpriseid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:userservice.MixInfo.enterpriseid)
}
#endif
inline void MixInfo::set_enterpriseid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  enterpriseid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userservice.MixInfo.enterpriseid)
}
inline void MixInfo::set_enterpriseid(const char* value, size_t size) {
  
  enterpriseid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userservice.MixInfo.enterpriseid)
}
inline ::std::string* MixInfo::mutable_enterpriseid() {
  
  // @@protoc_insertion_point(field_mutable:userservice.MixInfo.enterpriseid)
  return enterpriseid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MixInfo::release_enterpriseid() {
  // @@protoc_insertion_point(field_release:userservice.MixInfo.enterpriseid)
  
  return enterpriseid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MixInfo::set_allocated_enterpriseid(::std::string* enterpriseid) {
  if (enterpriseid != NULL) {
    
  } else {
    
  }
  enterpriseid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enterpriseid);
  // @@protoc_insertion_point(field_set_allocated:userservice.MixInfo.enterpriseid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace userservice

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_userservice_2eproto__INCLUDED
